# LGM - Turn-based Strategy Game

## Overview
LGM is a turn-based strategy game with a TypeScript backend API and Vue 3 frontend client. This server was generated by the [swagger-codegen](https://github.com/swagger-api/swagger-codegen) project using the [OpenAPI-Spec](https://github.com/OAI/OpenAPI-Specification).

## Quick Start with Nix (REQUIRED)

**Always use the Nix development environment for consistent setup:**

```bash
# Install Nix (if not already installed)
# https://nixos.org/download.html

# Enter the development environment (required first step)
nix-shell

# Install dependencies and start both servers
startup-servers
```

This provides Node.js, npm, git, and helpful development tools. The environment automatically creates the required `lib -> api` symlink and provides convenient aliases. See [NIX_SETUP.md](NIX_SETUP.md) for detailed instructions.

## Manual Setup (NOT RECOMMENDED - Use Nix instead)

### Running the API server (manual setup)
To run the server manually, first ensure you have Node.js 20.x and npm installed, then:

```bash
# Create required symlink
ln -s api lib

# Install dependencies and start API server
cd api
npm install
npm start  # Production server on port 3000
# OR
npm run monitor  # Development server with auto-restart
```

### Running the Frontend (manual setup)
```bash
# Install dependencies and start frontend
cd client  
npm install
npm run dev  # Development server on port 5173
```

### Tests

Run `npm test`.

Some tests only run if an env var is set:

`RUN_E2E_TESTS=true npm test`

or 

`RUN_E2E_TESTS=true npx mocha built/test/e2e.js` for just the e2e tests.


### Running Stryker.js Mutation Testing Locally

Run `npz stryker run --config-file stryker.conf.js` in the root directory of the project.

Stryker.js will perform mutation testing and provide a report on the code coverage.

# Architecture & Development

## üìã Architecture Documentation
For comprehensive architecture assessment and improvement recommendations, see:

- **[Architecture Assessment](ARCHITECTURE_ASSESSMENT.md)** - Detailed technical analysis and roadmap
- **[Architecture Checklist](ARCHITECTURE_CHECKLIST.md)** - Systematic review against best practices  
- **[Improvement Suggestions](IMPROVEMENT_SUGGESTIONS.md)** - Prioritized, actionable improvements
- **[Architecture Index](docs/ARCHITECTURE_INDEX.md)** - Quick reference and overview

## üõ£Ô∏è Development Roadmap
See [ROADMAP.md](ROADMAP.md) for current development priorities and [PLAYER_MANAGEMENT_IMPLEMENTATION_PLAN.md](PLAYER_MANAGEMENT_IMPLEMENTATION_PLAN.md) for detailed feature planning.

# TODO

## Joining Games

- **Limit number of players in a game:** Implemented (currently hardcoded to 4 per game).
- **Owner sets player limit when game is created:** Not implemented. Player limit is global.
- **Cannot join twice with the same user session/username in the same game:** Implemented.
- **User session may be joined to many games:** Possible. The system does not restrict a user from joining multiple different games.

## Game World

- **API to get state of the world for a given turn (for a specific player):**
  - The client application expects an endpoint like `GET /games/{gameId}/players/{playerId}` which would return the current game state (world, turn, etc.) for that player.
  - The backend service `GameService.turnResults` provides results of a completed turn, but a dedicated endpoint to fetch the full current game state for a player (as if they just joined or are refreshing) would be beneficial for the client.
